= Dr. Duke - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:xrefstyle: full
:repoURL: https://github.com/AY1920S1-CS2113-T14-1/main/tree/master

By: `CS2113-T14-1`      Since: `Sept 2019`      Licence: `MIT`

== Introduction

Welcome to the *Dr. Duke* developer guide! This document assumes a familiarity with the link:UserGuide.adoc[user guide].

In order to be a successful *Dr. Duke* developer, you need a general understanding of: +

* *Dr. Duke*'s architecture and object model
* The Java framework which *Dr. Duke* builds on

== Setting up
=== Prerequisites

. *JDK `11`* or above
. *IntelliJ* IDE
+

NOTE: IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +

This will generate all resources required by the application and tests.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* shown above explains the high-level design of *Dr. Duke*.

[[Design-UI]]
=== UI

[[Design-Logic]]
=== Parser Logic
image::plantuml/logic.svg[]

This class diagram describes the relationships between the various core classes involved in parsing the user's input into `Commands`. The first word (delimited by a space or newline) of the user's input is the _command name_. All commands extend the `Command` abstract class, which provides enough functionality for basic commands consisting of a single word. The operation of the `Command` is specified in the `execute` method. The mapping from the command name to the `Command` should be created in the `Commands` class, which is loaded by the default Parser constructor. A Parser can be constructed with subclass of `Commands` to specify a different set of commands.

All commands that have arguments extend `ArgCommand`. Each `ArgCommand` is associated with an `ArgSpec` singleton, whose private constructor sets the parameters of the `ArgCommand`: `emptyArgMsg` (the error message when no argument is supplied), `cmdArgLevel` (an `ArgLevel` enum indicating whether an argument for the command is necessary, optional, or forbidden) and the data structures `switchMap` and `switchAliases`, generated by the `switchInit` function. The `switchInit` function takes a vararg of `Switch` objects, which should specify the switches for the particular `Command`.

`switchMap` maps the full name of a switch to a `Switch` object, describing its properties, and `switchAliases` maps _aliases_ to the full name of the switch they represent. An alias is a string that, when provided by the user as a switch, is recognised as a specific switch. For example, for the switch `investigation` (given as `-i[nv(x|estigation)` in the User Guide) has the following aliases:

* `i`
* `in`
* `inv`
* `invx`
* `inve`
* `inves`
* `invest`
* `investi`
* `investig`
* `investiga`
* `investigat`
* `investigati`
* `investigatio`
* `investigation`

As this is would be very tedious to list manually, it is automatically generated by the `switchInit` function, using the data in the `Switch` objects provided to it. Observe that almost all these aliases are prefixes of the word `investigation`, with the shortest being `i`. This follows from the requirement that the switch can be recognised as long as the user has input enough characters for it to be unambiguous. Let `i` in this example be the _root_, the shortest unambiguous part of the full name of the switch. Then, every prefix of the word `investigation` starting from the root is an alias of the switch `investigation`. All these aliases can be generated by a loop in `switchInit`, from the root and the full name in the `Switch` object. Any additional aliases can be supplied via the `aliases` vararg in the `Switch` constructor. Refer to the Javadoc of `Switch` for further details on its fields.

In summary, to define a new `Command`:
* define a subclass of `Command`
* specify its execution in `execute`
* update `Commands` to link the command name to the `Command`

If this is an `ArgCommand`, in addition to doing the above for a subclass of `ArgCommand`:
* define a subclass of `ArgSpec` (by convention, `<name>Spec` is associated with `<name>Command`)
* define the private static field `spec` and the public static `getSpec` to provide singleton behaviour
* create a private constructor for the subclass
** define `cmdArgLevel` and `emptyArgMsg`
** construct the switches for the `ArgCommand` and supply them as arguments to `switchInit`

The Parser class scans through a user supplied string. The first word is extracted, and if the corresponding command is an `ArgCommand`, it uses several nested finite state machines which switch on the characters in the input the scan the rest of the input. Switches are extracted, using the aliases in `switchAliases` to identify the full names of the corresponding switches. The switch arguments are then compared against the requirements of the `ArgCommand`, as stored in the `switchMap`.

If a user-supplied switch is _not_ an alias for any switch, this triggers the disambiguation functions in `CommandHelpers`. We use a modified Levnshtein-Damerau distance which takes into account distance on a standard QWERTY keyboard in weighting the cost of substitutions and transpositions (pseudocode from https://dl.acm.org/citation.cfm?doid=1963190.1963191[here] and pointers for keyboard distance from https://stackoverflow.com/questions/29233888/[here]). The distance of the ambiguous string to every alias is calculated. If there is a switch with a unique lowest distance from the input string, that switch is automatically selected. If not, the user is prompted to select the appropriate switch from a screen.

[[Design-Model]]
=== Data Model

.Class Diagram
image::ClassDiagram.svg[]

The *_Class Diagram_* shown above describes the relationship among the different data classes used in *Dr. Duke*.

The `statusArr` stores the textual description of each numerical value for the `status`.

[[Design-Storage]]
=== Storage System 

[appendix]
== Product Scope

*Target user profile*:

*House officers*, who are typically freshly-graduated medical students, play a vital role in managing hospital patients.
They are responsible, among many other things, for collating all information regarding each hospital patient and
organising it to provide a clear picture of the patient's situation, and for presenting that picture to senior doctors
who can then make assessments and recommendations based on that picture. As much of this information needs to be
exchanged at a rapid pace, *Dr. Duke* assists in quick, accurate and efficient recording and retrieval of the patient
data required to provide effective care.

The house officers we are targeting with this app:

* need to manage a significant number of patients
* need to quickly input and organise patient data
* prefer desktop apps over other types
* prefer typing over mouse input
* can type fast

*Value proposition*:

* input, organise and access information about patients faster than with a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="100%",cols="10%,30%,30%,30%",options="header"]
|=======================================================================
| Priority | As a ... | I want to ... | So that I can...
| `* * *` | house officer | check my patients' allergies | issue them with the appropriate medicine

| `* * *` | house officer who has to manage a lot of information | flag and view the critical issues to
follow up for each patient | complete the follow-up(s) as soon as possible

| `* * *` | house officer who has to manage many patients | view the previous medical history of my patients
| understand what has been done to manage/treat their conditions

| `* * *` | house officer who needs to input a lot of data quickly and is prone to mistyping | be able to make typing
errors but still have my input recognised | avoid having to waste time to retype my command

| `* * *` | house officer who needs to input a lot of data quickly and is prone to mistyping | confirm my input type and
modify it quickly if it is incorrect | avoid having to retype or tediously transfer entries that were input in the
wrong place

| `* * *` | house officer who needs to upload records into the hospital's health system | generate unified reports that
are fully compatible with the system | avoid having to manually input those records

| `* * *` | house officer keeping track of information for my consultant | keep track of whether or not I've checked
for the results of certain investigations | make sure the consultant is kept up-to-date

| `* * *` | house officer who has to manage a lot of information | easily link new information and follow-up items to
particular conditions | have a clearer picture of each condition and its corresponding management plan

| `* *` | house officer with a consultant that talks too fast | differentiate the types of input with just a single
control character | avoid having to waste time switching between windows

| `* *` | house officer who has to manage a lot of information | easily view and navigate through data associated with
particular conditions that particular patients have | have a clearer view of what that particular condition is

| `* *` | house officer who needs to input a lot of data quickly and is prone to mistyping | undo my previous commands |
quickly rectify mistakes made when inputting data

| `*` | house officer who has to manage a lot of information | search through all of the records of a patient | find all
the details relevant to a particular aspect of his/her care plan

| `*` | house officer who has to manage many patients | easily view all critical issues all my patients are facing by
level of importance | address them as soon as possible

| `*` | house officer who needs to input a lot of data quickly and is prone to mistyping | have my input automatically
checked to ensure it is of the right format | always be assured that I am inputting the right commands.
|=======================================================================

[appendix]
== Use Cases

(For all use cases, the *System* is `Dr. Duke` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== [[UC-1]] Use case: UC1 - Add a patient

*MSS*

. User requests to add a patient.
. Dr. Duke requests for details of the patient.
. User enters the requested details.
. Dr. Duke creates a new profile for the patient according to the specified details.
+
Use case ends.

*Extensions*

* 3a. Dr. Duke detects an error in the entered details.
+
** 3a1. Dr. Duke prompts the user with an error message and requests for the correct details.
** 3a2. User enters correct details.
** Steps 3a1 and 3a2 are repeated until the given details are valid.
** Use case resumes from Step 4.

[discrete]
=== [[UC-2]] Use case: UC2 - Edit a patient's details

*MSS*

. User searches for the patient <<UC-3,(UC-3)>>.
. Dr. Duke requests for new details of the patient.
. User enters new details of the patient.
. Dr. Duke updates the profile for the patient.
+
Use case ends.

*Extensions*

* 3a. Dr. Duke detects an error in the entered details.
+
** 3a1. Dr. Duke prompts the user with an error message and requests for the correct details.
** 3a2. User enters correct details.
** Steps 3a1 and 3a2 are repeated until the given details are valid.
** Use case resumes from Step 4.

[discrete]
=== [[UC-3]] Use case: UC3 - Search for a patient

*MSS*

. User enters the patient's name.
. Dr. Duke returns list of all relevant results.
. User selects the target patient in the list.
+
Use case ends.

*Extensions*

* 2a. The returned list is empty.
+
Use case ends.

[discrete]
=== [[UC-4]] Use case: UC4 - View a patient's records

*MSS*

. User searches for the patient <<UC-3,(UC-3)>>.
. Dr. Duke shows the detailed records of the patient.
+
Use case ends.

[discrete]
=== [[UC-5]] Use case: UC5 - Discharge a patient

*MSS*

. User searches for the patient <<UC-3,(UC-3)>> and requests to discharge him/her.
. Dr. Duke shows the details of the patient and requests for a confirmation.
. User confirms that the patient may be discharged.
. Dr. Duke generates a discharge report for the patient and delete his/her record from the system.
+
Use case ends.

*Extensions*

* a. At any time, User chooses to cancel the discharge operation.
+
** a1. Dr. Duke requests to confirm the cancellation.
** a2. User confirms the cancellation.
+
Use case ends.

[discrete]
=== [[UC-6]] Use case: UC6 - Generate a unified report for a patient

*MSS*

. User searches for the patient <<UC-3,(UC-3)>> and requests to generate a report on his/her current health condition.
. Dr. Duke generates a detailed report for the patient.
+
Use case ends.

[discrete]
=== [[UC-7]] Use case: UC7 - Undo previous command(s)
*Preconditions*: At least 1 command in the command history.

*MSS*

. User requests to undo previous command(s).
. Dr. Duke shows the list of command(s) to be reverted and requests for a confirmation.
. User reviews the command(s) and confirms the undo operation.
. Dr. Duke performs the undo operation and returns the system to an older state.
+
Use case ends.

[appendix]
== Non Functional Requirements

. The software should be portable, i.e. work on any <<mainstream-os,mainstream OS>> as long as the OS has Java `11` or
  above installed.
. The software should be able to hold up to 500 patients without a noticeable reduction in performance for
  typical usage.
. The software should work without internet access.
. The software should have good user documentation, which details all aspects of the software to assist new
  users on how to use this software.
. The software should have good developer documentation to allow developers to understand the design of the
  software easily so that they can further develop and enhance the software.
. The software should be easily testable.
. A user with an above average typing speed for regular English text should be able to accomplish most of his/her
  intended tasks faster using commands than using the mouse.
. All data transactions should be atomic - either they succeed and the persistent data storage is immediately updated,
  or they fail and the user is notified of that event, with the data being unchanged.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
* Windows
* macOS
* Linux
