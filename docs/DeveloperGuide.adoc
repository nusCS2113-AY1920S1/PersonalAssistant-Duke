= Ducats  - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-F09-4/main

By: `AY1920S1-CS2113T-F09-4` Since: `Aug 2019`

== Introduction

Amateur musicians find it difficult to start with music theory as they are unable to see their work being shown in a
practical method and quit. Our application allows amateur musicians to learn music theory and apply their learning by
creating songs.

This application allows you to learn what you have learnt through:

* Ease of adding, deleting components to the songs

** The user is able to add, delete, edit and view components such as bars, notes, groups to the song so that they learn
the  basics of creating a song.

* Displaying the musical notes as sheets so that they can practice it in their favorite instrument.

** In the end once the user uses the application, they will be able to take away a pdf of their musical notes and also
print it in command line.

This document describes the coding style and the architecture of the Ducats project built by Team CS2113T F09-4.
This document is intended for our major release v1.3.

The documentation will allow any developer to start to work on the project by first learning about the system
architecture, then the implementation and lastly on how to document the code that is written.


== Setting up

To set up the program successfully, at minimum, JDK 11 is needed. IntelliJ Ultimate is the preferred IDE due to its ease in building the project. The steps to set up the project in your computer are as follows:

1. Fork the link:https://github.com/AY1920S1-CS2113T-F09-4/main[Github repository] and clone the fork to your computer.
2. Open Intellij (If you are not on the welcome screen, close the current project by navigating to *File* > *Close Project*.
3. Setup the correct JDK version:
.. Click *Configure* > *Structure* for new projects.
.. Under *Project Settings* click on *Project*.
.. Under *Project SDK* click *New* and point it to JDK 11 path.
.. Click *OK* to save the configuration.
4. Run the Project by editing the run configuration to point to
Ducats.java as the main class.

== Design

This section describes the design of Ducats, starting with the overall architecture, and then proceeding to the a more detailed view of the major components.

=== Overall Architecture

Ducats consists of multiple components implemented as objects that work together to fulfill the program's objectives. Figure 1 below showcases the high-level architecture of Ducats:

.Architecture Diagram
image::Architecture_Diagram.png[]


Ducats, the main class, is responsible for the initialization of the different components, as well as the highest level of logic.

DucatsLogger is a common class used by many of the components in order to log information, warnings and errors in a `.log` file.

Other than the two components mentioned above, the rest of the components are linked in a way reminiscent of an n-tier architectural style, with the higher-level components making use of the services provided by the lower-level components. The remaining seven components are as follows:

* `UI`: interacts with the console (reading and writing)
* `Parser`: parses the input command and creates of the appropriate Command object
* `WordGetter`: suggests the correct command to the user if the user misspells his command
* `Command`: executed to modify the UI, SongList and Storage
* `SongList`: contains the list of Song objects
* `Metronome`: displays a visual metronome on screen when initialized through a `MetronomeCommand`
* `StorageParser`: parses data in persistent storage and converts song data to a form friendly to be stored in persistent storage
* `Storage`: Reads data from and writes data to persistent storage in the hard disk

Each of these classes have their API illustrated in their respective files.

=== UI

*API*: link:https://github.com/AY1920S1-CS2113T-F09-4/main/blob/master/src/main/java/ducats/Ui.java[`Ui.java`]

This layer consists of the `UI` Class which is in charge of printing the output to the command line in a specific format. This was chosen instead of printing the output from every individual class as we opted to do abstraction to make it simpler when adding new features. This class also receives messages from users and passes them to the parser layer, which decides which class to be called.

=== Parser and Commands

=== SongList

=== Storage and StorageParser

*Storage API*: link:https://github.com/AY1920S1-CS2113T-F09-4/main/blob/master/src/main/java/ducats/Storage.java[`Storage.java`]

*StorageParser API*: link:https://github.com/AY1920S1-CS2113T-F09-4/main/blob/master/src/main/java/ducats/StorageParser.java[`StorageParser.java`]

The Storage layer, implemented by the `Storage` class, is responsible for Ducats' interaction with persistent storage of the SongList, which is in the form of a directory called *data* containing `.txt` files that each contain the full data for one Song.

The StorageParser layer's purpose is to parse the data found within the persistent storage, as well as to convert the data found within the SongList to a human-readable, storage-friendly form. This layer is implemented by the `StorageParser` class.

== Implementation

This section describes in detail the implementation of the various features, as well as how the different components interact with each other.

=== Command Parsing and Execution

Since Ducats is a CLI app, it works by reading user input and carrying out the command the user wants it to execute. In line with this objective, the different components of Ducats have been designed to interact in the sequence as depicted by Figure X.

.Command Parsing and Execution Sequence Diagram
image::Command_Sequence_Diagram.png[]

In the above diagram, 'XYZ' is used to represent a general command or function. There are several different types of possible commands that can be created after parsing, and hence the object is labelled "XYZCommand". Similarly, to format the output string, there are multiple method within the UI class of doing so, hence being represented here by "XYZFormat()".

It can be seen that, for all commands, the `Parser` class is used to determine what type of command the user intends for the program to execute, and then creates the appropriate command with the full message text as a parameter. Then, the `execute()` method of the Command is called, modifying the `SongList` and `Storage`, and returning a String to be displayed on the console through the `UI` class.

A slightly different schedule is used for the Metronome functionality, which will be discussed in further detail in Section 4.5.

=== Basic CRUD

CRUD stands for "Create, Read, Update, Delete", and this framework serves as the most essential part of any data-driven software. In Ducats, basic CRUD functionality is implemented, alongside more sophisticated features such as the ability to Undo and Redo.

==== Creating a Song and Navigation

The creation of a new song is straightforward. In the `new` command, the following attributes of the song to be created will be specified:

* name
* key _[implementation coming in v2.0]_
* time signature _[implementation coming in v2.0]_

While the above data is stored with every song, data adjustments based on, and specific methods that utilize the key and time signature are yet to be implemented.

The created Song object will then be inserted into the SongList object, which contains all the song data of Ducats. Following this, persistent storage will be updated.

In order to enable the modification of certain songs when there are multiple songs without the forced provision of additional parameters by the user, a system of navigation has been implemented, where a song can be "opened" in order for it to be edited, with the first song in the SongList being "opened" by default. "Opening" a song is carried out by the execution of the `OpenCommand`, which changes a variable in the `SongList` object known as the `activeIndex`.

`activeIndex` corresponds to the index of the song that can be edited by the other CRUD functions, and only by modifying this attribute to the appropriate value can songs other than the first one be editable. For example, consider the situation where the SongList contains two songs titled "twinkle" and "dreams".

image::songlist_activeIndex1.png[]

In this case, as the default `activeIndex` is set to `0`, the user can enter `open dreams` in the CLI to make sure he is editing the song titled "dreams".

image::songlist_activeIndex2.png[]

When the main class executes the command, the command will first try to find the index of the provided song in the song list.

    String songName = message.substring(5);
    int songIndex = songList.findSongIndex(songName);

findSongIndex(songName) conducts a linear search on the SongList to return the index of the song that has the given name, and returns -1 is the song is not found. By querying the return value, Ducats either sets the activeIndex of the SongList or throws and then handles a DucatsException. The former is carried out with the `setActiveIndex()` method of the SongList class.

    songList.setActiveIndex(songList.findSongIndex(songName));

For future CRUD commands, the specific SongList method invoked by the `execute()` method takes in the activeIndex as a parameter and proceeds to perform the necessary operations on the SongList, as shown below.

image::songlist_activeIndex3.png[]

_Design Considerations_:

* Use binary search instead of linear search for `findSongIndex()`
** _Pros_: Higher efficiency in navigation
** _Cons_: the `list` in the SongList needs to be sorted, and insertion in a sorted manner, along with the implementation of binary search, for minimal gains in efficiency, seems to violate KISS

* Let the user input the index of the song rather than the name
** _Pros_: Faster input of command for the user, no need for `findSongIndex()`
** _Cons_: User needs to look at the full list first, so overall, time is not saved. For the user, querying a name is more natural than an index.

Hence, we have decided to go for a linear search for `findSongIndex()`, and let the user input the song name to open the song instead of the index.

==== Modifying a Song

=== Advanced CRUD

==== Undo/Redo

==== Overlay

==== Group and Copy

=== Display

=== Metronome

A metronome is a device that outputs sound at regular, adjustable intervals, commonly used by musicians to more easily play at a particular tempo. In Ducats, the main purpose of the Metronome functionality (accessed through `MetronomeCommand`) is to provide a visual presentation of a particular tempo and time signature, so that the user can more easily understand what an appropriate tempo for their song would be.

Due to a reliance on multi-threading through the Timer library, the execution of the functionality is not carried out in the `UI` task, whose primary purpose is to display and read console content. Instead, a `Metronome` object is initialized in the main class, and `MetronomeCommand` will provide the object with the following parameters:

* duration (in bars)
* tempo (in BPM)
* time signature

Following this, the `TimerTask` of generating the appropriate output to the console will be executed by a new `Timer` object initialized in the `start()` method of the `Metronome` object. The overall sequence diagram can be seen in Figure X.

<insert seq diagram specific to Metronome>

=== Autosuggest

=== Storage

In order to ensure that the songs the user has created, deleted or modified can be retrieved even after exiting Ducats, a form of persistent storage is needed. This is implemented as a folder containing `.txt` files, and a `Storage` class that will interact with the said folder to read and modify its contents. Since the `Storage` class can create and modify files, it is important to understand the exact procedures executed within the class. This is shown below in Figure X.

<insert activity diagram of Storage>

// todo: elaboration

_Design Considerations_:

* Using a single .txt file to store all the data
** _Pros_: easier implementation of `Storage`
** _Cons_: harder for the user to import and export files without corrupting the data, complicated parsing in `StorageParser` required to get the full data, hard for the user to view the data if the song is too long due to line length limits on most `.txt` file editors
* Using .csv files instead of .txt files to store the data
** _Pros_: arguably a more organized method of data management
** _Cons_: difficult to store song data of varying lengths in a meaningful way that would make a `.csv` file more ideal than a `.txt` file

We have decided to use a storage directory that contains `.txt` files, each containing a single song's data. With this implementation, it is easy for the user to export and import songs by just copying out or inserting .txt files of the same format respectively. Additionally, having a folder instead of a single file is neater for the user's file management, hence enhancing the user experience.

=== Logging

== Adding a New Function

== Testing

[appendix]
== Product Scope

Target user profile:

* Is passionate in producing music
* Is new to music composition
* Has little to no background in music theory
* Can effectively use the keyboard
* Prefers typing over mouse input
* Is reasonably comfortable using CLI apps

_Value proposition_:
Quick and seamless composing, editing and saving of music.


[appendix]
== User Stories

[cols=4*]
|===
|Priority
|As a(an) ...
|I want to ...
|So that ...

|3
|amateur composer who does not want to be overwhelmed with music theory
|know the different ways and options to compose music in a simplified way
|I have a way to start learning about music composition

|3
| a self-taught musician who has no prior musical theory knowledge
| visualize the songs I create and play in an intuitive yet comprehensive way to
| I have a tangible way to represent and record my songs.
| 3
| pianist who is not pitch perfect
| check out how certain specific chords sound in a convenient way
| I can identify when I play the wrong chords
| 2
| electronic music enthusiast
| create music that cannot be created with a physical musical instrument
| I can create new music
| 2
| electronic music composer
| save my music as mp3 file
| I can share it with others
| 1
| musician who wants to start composing my own accompaniment
| an easy-to-use platform to test out how the accompaniment would sound together with my musical piece
| it is easier for me to create my accompaniment
| 3
| As someone who doesnâ€™t have any musical instruments
| I want to be able to learn about basic music theory without buying any instruments
| I can create my own music and feel proud
| 2
| As an electronic music enthusiast,
| I want to create music that cannot be created with a physical musical instrument
| that I can create new music.
| 3
| As an electronic music composer
| I want to save my music as mp3 file
| so that I can share it with others
| 2
| As a newcomer to music
| I want to have tips or tutorial on creating good music in the software
| so that I can learn to create good and simple music through the app
| 3
| As a newcomer to music
| I want the app to tell me about my progress in learning music
| So that I can gauge my performance.
| 2
| As an amateur music creator
| I want to be able to group certain rhythms and melodies that I compose
| So that I can easily copy paste these rhythms and melodies to create long music
| 3
| As an amateur music creator
| I want to group together notes that I find sounds good to create rhythms and melodies
| so that I can reuse them later as I compose the music.
| 4
| As an experienced composer
| I want an fast and easy way to hear out small snippets of my musical pieces.
| This is so that it is easier for me pick out which notes to improve on and alter.
| 4
| As a wannabe composer
| I want to be able to change the key of the song I am working on.
| So that I can create or remix new songs.
| 3
| As a wannabe composer
| I want to be able to easily set the time signature of the song I want to compose.
| So that I can create or remix new songs.
| 4
| As an experimentalist musician
| I want to be able to explore the sounds of different chords. Priority.
| So that I can test it and create new songs.
| 3
| As a fan of music
| I want to quickly listen to what I have composed.
| So that I can share with my friends.
| 4
| As a music lover
| I want to be able to easily edit songs in a command line interface.
| I can share it with my musical buddies.
| 4
| As a person who enjoys music
| I want to be able to jot down my musical ideas in a quick and seamless way.
| I can share it with my friends.
| 3
| As a computer engineer with little to no experience in music
| I need a tool to instantly combine two songs or voice for a presentation
| I can share it with my friends.
| 4
| As a parent
| I want to teach my kid the practicality approach of creating a song
| so that i can gauge their interest level in music.
| 4
| As a person who is just starting off with piano
| I would love to know if there is an app that allows me to compose music
| so that I can learn practically.
| 3
| As a person who loves to analyse music
| I want to know the notes in the music.
| I can learn from it.
| 4
| As a person who is into remixing
| I want a simple tool to remix different songs in a simple and intuitive way.
| I can create my own songs
| 4
| A person who loves to create music
| I really want to copy portions of a song into another
| I can do it as a hobby!
|===

[appendix]
== Use Cases

(For all use cases below, the *System* is the Ducats program and the *Actor* is the user)

Use case: Delete song

. User requests to list songs
. Ducats shows a list of songs
. User requests to delete a specific song in the list
. Ducats deletes the song _[Use case ends]_

Extensions:

2a. The list is empty _[Use case ends]_

3a. The given song name is invalid

3a1. Ducats shows an error message _[Use case ends]_

Use case: Create song

. User requests the format to create song using help
. Ducats shows a list of commands
. User lookup for the specific song creation command
. Ducats shows the format for creating a song
. User input a song according to the format
. Ducats create the song and store it into the storage

Extensions:

3a. The input command name is invalid

3a1. Ducats shows an error message _[Use case ends]_

5a. The input format is incorrect

5a1. Ducats shows an error message _[Use case ends]_


[appendix]
== Non-Functional Requirements

* Response should be as fast as possible as there is no online communication and any complicated back-end algorithms. Response should be within 0.7s.
* The product should work on all modern devices regardless of Operating System.
* The product should show data in a human-readable, human-editable way in order to allow for easy manual entry and easy exporting of data.
* The product should be intuitive and easily utilized with reference to an accompanying User Guide and/or Developer Guide.
* The product should have clear updates that indicate what features have been added, removed or modified.
* The product should not be excessively battery and resource intensive.
