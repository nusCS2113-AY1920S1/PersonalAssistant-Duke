= DIYeats - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toclevels: 2
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:warning-caption: :warning:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-W13-4/main

By: `Team 13-4`      Since: `Sept 2019`      Licence: `MIT`

== Introduction

*DIYeats* is an application designed to help NUS students plan out their diet in order to maintain a healthy lifestyle,
which can often times be a challenging endeavour amidst the intense academic rigour associated with university life.

*DIYeats* utilizes a command line interface, and is compatible with most modern OSes
(Windows, Macintosh, Linux, Ubuntu). Commands are designed to be simple and intuitive, such that even users who are
unfamiliar with the command line interface can use it with ease.

*DIYeats* also comes with a GUI wrapper for the command line interface.

To jump to a specific topic immediately, simply click on the topic in the <<toc, Table of Contents>> at the top

To improve the navigability and readability of this developer guide, multiple styles will be used, which will
include the following:

* User commands and parameters will displayed as: `format`
* Important keywords will be displayed as: *format*
* Keyboard buttons will be displayed as: kbd:[format]


Additionally, the following annotations will be used throughout this user guide:

[TIP]
====
This symbol denotes a tip which you may find useful when using the application.
====
[WARNING]
====
This symbol denotes a warning which you will need to be careful of when using the application.
====
[NOTE]
====
This symbol denotes some information or caveats that you will need to take note of when using the application.
====

== Setting up the project in your computer

=== Software prerequisites

. *JDK 11*
+
[NOTE]
Only JDK 11 is officially supported
. *IntelliJ IDE*
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

=== Project setup
. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

== Design
=== Architecture
.Architecture Diagram
image::architecture.png[width="500"]

The figure above illustrates how our program might look like from a high-level perspective. Each of the major processes in the figure above will be elaborated on in the following sections.

`Main` has one function `run` which is executed immediately when the program is run. This function is responsible for:

* At application launch: initialize the UI, Model, Storage and Logic components of the code in the correct sequence

* During application runtime: support high level exchange of information between each of the aforementioned component

* At shutdown: Stop all running processes, and initiate any cleanup methods whenever required

=== Model
.Model Diagram : Meal Management
image::model.png[width="800"]

The Model component of the code is in charge of tracking and managing all of the meal data involved during the application's runtime. It accomplishes this by:

* Initializing a MealList object, which stores:
** All of the user's meal info
** All of the previously defined default meal values
* Initializing a Goal object, which stores the user defined dietary targets to be met.
* Being capable of operating independently of all the other code components.

.Model Diagram: Cost Management
image::transactionmodel.png[width="800"]

The Model component of the code is in charge of managing the transaction data involved during the application's runtime. It accomplishes this by:

* Initializing a TransactionList object, which stores
** All of the transactions information (e.g. transaction amount, dates of transaction).
* Being capable of operating independently of all the other code components.

=== Storage
.Storage Diagram
image::storage.png[width="800"]

The storage component of the code is in charge of reading and writing to files in the Data package of the main program directory. it accomplishes this by:

* Initializing a Load object, which:
** Is capable of reading and parsing data from the text save files in the Data directory, using its constituent functions as well as subsidiary classes.
** Being capable of operating independently of all the other code components.
* Initializing a Write object, which:
** Is capable of writing data to the text save files in the Data directory, using its constituent functions.
** Being capable of operating independently of all the other code components.

=== Logic
.Logic Diagram
image::logic.png[width="800"]

The Logic component of the code is in charge of parsing all of the user's commands and executing them. It accomplishes this in the following steps:

. The UI receives a command from the user, and sends it over to the Logic component
. The Parser object in the Logic component receives the command, and calls the autocorrect function to correct any typo errors present in the command
. The corrected command is inserted in the commandHistory
. Depending on the type of command issued, the parser calls the commandparser associated with the command, which parses the command into its relevant data chunks.
. A command object relevant to the user given command is then instantiated from the data in the user given command
. The command object is then passed to the main function, which immediately executes it

=== Ui
The Ui component of the code is in charge of:

. Executing all user commands through the Logic component
. Presenting data from the model component of the code to the user through the command line interface

== Implementation

As of now, all commands entered by the user go through the following validation checks:

. The autocorrect function takes in the user input, and determines if there are any typos present in the user input.
* If autocorrectable typos are present, the program attempts to replace the erroneous text with the correct command from a predetermined set of words.
* If no typos are present, or there exists a word that cannot be autocorrected, the command is returned as is to the parser.
. This autocorrected command is then subjected to additional checks in the `*CommandParser` class (e.g AddCommandParser, EditCommandParser, etc.), which ensures that the command structure is correct.

=== User initialization

User initialization personalises the program for each user to cater to their needs

This section describes the implmentation and design considerations.

==== Current implementation

On start up, `Main` will load `user.txt` file. If no data is found, `Main` class will instead ask for user information before starting the program.

The following step describes the flow of the initialisation:

. The `Main` class will load `user.txt` via `Storage` class and check if there is user data already stored.
.. If no data is found, `Main` will request for user to input personal data in this order:
... `Name`
... `Age`
... `Weight`
... `Height`
... `Activity Level`
... If they would like to maintain or lose weight
.. If data is found, `Main` will load the data from `user.txt` via `Storage`
. The `Main` will continue on with the function.
. On exit, `Main` will save the `User` data to `user.txt`

==== Design considerations

Problem 1: *How to store weight data to be displayed over time*

*Solution 1 (current implementation): HashMap
** By storing data in HashMap, we are able to store a weight data to a date and this can be changed easily by accessing the same date in the HashMap.

=== Add command

The Add feature gives the user the ability to assign default nutritional values associated with certain meal names.

This section describes the implementation and design considerations involved in the Add feature, and how the Add feature expedites user input.

==== Current implementation
Assuming that there are no preexisting default values assigned to meals, and the user inputs the `add` command `add hotcakes /calories 300`, the application processes the command through the following steps:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.

. After parsing, the data is then used to create an instance of the `AddItemCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `AddItemCommand#execute()` function.
. The `AddItemCommand#execute()` function then further invokes the `MealList#addStoredItem(...)` function, which stores the data in a `storedItems` object of type `HashMap<String, HashMap<String, Integer>>`, in the following format:
* The key of the encapsulating hashmap is the name of the meal that is to be assigned default values, in this instance, it has only one member `hotcakes`
* The internal hashmap associated with the key `hotcakes` is used to store the nutritional tags (e.g calories, sodium, etc.), along with the default quantity associated with it. In this case, the internal hashmap only has one key `calories`, which is associated with the integer value `300`

The steps carried out by the program as described above are captured in figure 5, the sequence diagram as shown below.

.Add command sequence diagram
image::addcommand.png[width="800"]


=== Mark as Done command

The Mark as Done feature gives the user the ability to mark the meals they have eaten as done and this will update the calorie they can eat for the rest of the day, the application processes the command through the following steps:

==== Current Implementation
Assuming that the index in the user input is not outside the boundary of the meals on that certain day, the implementations are as follows:

. The `Main` class calls the parse function of the `Parser` class to parse the user input which consist of the index of meal marked done and the specified date.
. After parsing, the data parsed is used to create an instance `MarkDoneCommand` object, which is the returned to the `Main` function.
. The `Main` function would then invoke the `MarkDoneCommand#execute()` function.
. The `MarkDoneCommand#execute()` function will invoke the function `MealList#markDone(...)` which update the state of the specified meal.
. The `MarkDoneCommand#execute()` function will also invoke the `ui#showCaloriesLeft` which will calculate the amount of calories left to be eaten in that day.

=== Transaction command (Will be implemented by `v1.3`)

The Transaction feature gives the user the ability to manage their accounts when it comes to choosing meals of different prices.

==== Projected Implementation
Assuming that there is enough balance in the user account, the application processes the commands through the following steps:

. The `Main` class calls the parse function of the `Parser` class to parse the user input.
. After parsing, the data parsed are then used to create an instance of the `AddTransactionCommand` object, which is then returned to the `Main` function.
. The `Main` function would then invoke the `AddTransactionCommand#execute()` function.
. The `AddTransactionCommand#execute()` function the furthers invokes the 'user#updateAccount(...)' function, which update the data of the account balance of the user.

=== Sort command

The Sort feature gives the user the ability to sort the data according to nutritional value or based on costs.

This section describes the tentative implementation and design considerations involved in the Sort feature and how the Sort feature works.

==== Projected implementation
In the event where the user would like to sort the default meals from the least amount of calorie, the user inputs `sort /calories /ascending`, the application processes the command through the following steps:

. The `Main`` class calls the parse function of the `Parser` class to parse the user input. During this stage, the following validation checks are carried out before parsing:
. After parsing, the data is then used to create an instance of `Sortcommand`, which is then returned to the `Main` function.
. The `Main` function would then invoke the the `SortCommand#execute` function.
. The `SortCommand#execute()` function then sort the invoke the `storage#LoadFile` function, which fetches the data from the default meal text file and update the generate a mealList.
. The mealList will then be sorted based on the calorie content in ascending order and and displayed to the user through `ui#showList`.

==== Design considerations

Problem 1: *How to store the data associated with this command*

* Solution 1 (current implementation): Hashmap of a Hashmap
** By storing the data in this format, this feature can be easily extendable to store multiple different default values associated to different nutritional tags to a single meal. Additionally, read and write access can be carried out in approximately O(n) time, where n is the amount of nutritional tags associated to a single meal. As n is unlikely to be large (n > 10), the process is not time complex.

Problem 2: *Where to instantiate the data structure used to store the data for this command*

* Solution 1 (current implementation): Directly in the MealList data structure
** By instantiating the data structure directly in the MealList data structure, it becomes straightforward to access the data whenever a new meal is added.
** However, this violates the separation of concerns architecture principle
* Solution 2 (planned implementation by v1.3): In a separate class
** By instantiating the data structure in a different class, it improves the cohesion of the code, and satisfies the separation of concerns principle




=== Suggest  command

The Suggest command provides the user the ability to get personalized meal recommendations from our application based on the current database of food available in our application as well as the food habits of the user, all while ensuring the user has a healthy meal that matches his/her lifestyle and calorie limit.

The following section describes the implementation and design considerations involved in the Suggest feature, and how the Suggest feature facilitates meal recommendations.

==== Current implementation
The Suggest command assumes that there is a pre-existing list of food items from which it can suggest food from and that this list contains food parameters such as cost, calories, nutrients, etc. This is a sample of how this feature will work in principle:

. When the application is being initialized, the `Storage#load()` function will be utilized to load all the meal parameters to memory in the `MealList` object.

. The `MealSuggestion` class will be created and hold a reference of the `MealList` object to perform data analysis for meal suggestion when requested by user.

. After the application initializes, every time the user keys in a meal entry, the `MealSuggestion` class will update its mealFrequency parameter of the meal for the respective week.

. Once the user enters the suggest command
    * Parser checks if date is provided, else defaults to current date (based on system clock)
    * Parser checks if meal parameters are provided, else defaults to all parameters.
    * Autocorrect will work on all the input provided by the user to prevent repeated entering of command due to typo from user.

. `MealSuggestion#getMealPreferenceScore(...)` function computes the meal preference score of each meal based on the date provided and the meal parameters the user wants.

. `MealSuggestion#getMealSuggestion(...)` function sorts the meals based on the preference score calculated and returns most suitable meal to the user.


==== Design considerations

Problem 1: *How to determine most suitable meal for user*

* Solution 1: Assign total meal preference score of each meal in a list and provide meal suggestion based on the overall lowest cost of meal preferance score.

** Pros: Provides a way to compare various meal parameters together in which a total preference cost can be computed by by summing all the normalized parameter values.

** Cons: Requires a non-trivial way to normalize all the different parameter values. Example: Is a $1 cheaper meal worth 100 more calories to the user?

* Solution 2: Calculate the ranking of each parameter of each meal with the rest of the meals and provide meal suggestion based on the meal with the lowest ranking in as many of the parameters specified by the user.

** Pros: Simple to implement as it performs a static ranking of all the parameters of each meal.

** Cons: Has no way to objectify the difference across different parameter categories. Example: A very healthy meal that is very nutritious but costs $30 will likely be suggested to the user as it performs the best in all categories except price, giving it the lowest overall ranking although it costs 3 times as much as any other meal.

Problem 2: *How to prevent excessive repeated meal suggestions*

* Solution 1: Add another parameter to each meal that tracks the number of times the user has eaten that meal over a week and ensure the number does not cross a threshold maximum.

** Pros: New parameter created is easy to implement and is objectively able to limit the meal suggestions based on a threshold amount of times the food has been eaten.

** Cons: Arbitary threshold number may not work well for different users who have different preferences of how often they mind eating the same meal over a week.

* Solution 2: Provide a random meal suggestion based on the top few meals ranked by the preference score (within some tolerance to prevent low scoring meals from being accidentally suggested).

** Pros: Very easy to implement and allows for a (somewhat) guaranteed way to mix up the meal suggestions such that the meal is not consumed too often.

** Cons: Undeterministic meal suggestion that provides different meal suggestion given the same input parameters. There is still a small chance that the same meals can be suggested repeatedly.




== Documentation
=== Introduction

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Docs-SiteWideDocSettings]]
=== Site-wide Documentation Settings

The link:{repoURL}/build.gradle[`build.gradle`] file specifies some project-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how all documentation files within this project are rendered.

[TIP]
Attributes left unset in the `build.gradle` file will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of site-wide attributes
|===
|Attribute name |Description |Default value

|`site-name`
|The name of the website.
If set, the name will be displayed near the top of the page.
|_not set_

|`site-githuburl`
|URL to the site's repository on https://github.com[GitHub].
Setting this will add a "View on GitHub" link in the navigation bar.
|_not set_

|`site-seedu`
|Define this attribute if the project is an official SE-EDU project.
This will render the SE-EDU navigation bar at the top of the page, and add some SE-EDU-specific navigation items.
|_not set_

|===

[[Docs-PerFileDocSettings]]
=== Per-file Documentation Settings

Each `.adoc` file may also specify some file-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how the file is rendered.

Asciidoctor's https://asciidoctor.org/docs/user-manual/#builtin-attributes[built-in attributes] may be specified and used as well.

[TIP]
Attributes left unset in `.adoc` files will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of per-file attributes, excluding Asciidoctor's built-in attributes
|===
|Attribute name |Description |Default value
|`site-section`
|Site section that the document belongs to.
This will cause the associated item in the navigation bar to be highlighted.
One of: `UserGuide`, `DeveloperGuide`, `AboutUs`, `ContactUs`
|_not set_
|`no-site-header`
|Set this attribute to remove the site navigation bar.
|_not set_

|===

== Testing
=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


== Dev Ops
=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews

When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the https://github.com/FasterXML/jackson[Jackson library] for JSON parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives:

[loweralpha]
. Include those libraries in the repo (this bloats the repo size)
. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Value Propositions

**Target User Profile:**

NUS Students who are trying to plan their meals for a specific diet goal such as losing weight, maintaining weight, or building muscle.

**Propositions:**

* DIYeats makes it radically easy to maintain and keep track of your daily nutritional intake in a single Command Line Interface (CLI) and Graphical User Interface (GUI).
* DIYeats lets you set your own weight goal based on your height and your activity level.
* DIYeats gives you liberty to follow any eating style and create your own customized meals.
* DIYeats allows you to plan ahead and reduce the food waste due to overshopping groceries.
* DIYeats plans on integrating all food items in NUS into its database, which can allow it to suggest meals in NUS that would allow the user to meet their nutritional targets.
* DIYeats elegantly displays the progress of your diet to help you motivate yourself and others.
* DIYeats saves your effort and efficiently suggest and plan the meals for you.

[appendix]
== User Stories
[width="80%",cols="20%,<20%,<30%,<30%",options="header",]
|=======================================================================
|Priority |As a... |I want to... |So that I can...
|HIGH |NUS student |be able to plan my meals ahead |I know beforehand what to eat the next day, amidst my busy schedule
|HIGH |NUS student |list of dishes and each nutritional value in NUS Canteens| I can make an informed decisions to pick healthier meal
|HIGH |NUS sportsman |track the amount of nutrition I need to take in a day |I can plan my meal and avoid overeating/undereating
|HIGH |someone looking to lose weight |track the daily calories intake based on my target body weight |I am able to regulate the amount of food I eat in the day
|HIGH |unregistered user |create a customized profile of myself (e.g. weight and height)| I don’t have to input the profile every time I open the application
|HIGH |vegetarian |create a meal plan that does not require meat or dairy product |I could eat healthy with my vegetarian preference
|MEDIUM |someone who is not great at typing |an autocorrect feature |I don’t input incorrect dish names
|MEDIUM |forgetful user |remind myself of the available commands in an application |I don’t have to waste my time rustling through user guide
|MEDIUM |forgetful user |have a way to remind me how much nutrition I have to take to reach the target nutrient intake |I could plan my subsequent meal accordingly
|MEDIUM |careless user |be able to revert changes done previously |I don’t have to manually revert the changes
|MEDIUM |efficient user |clear and add multiple meals at once |I don’t have to input the same command multiple times
|MEDIUM |efficient user |add a recurring meal (every week, biweekly) |I don’t have same command multiple times
|MEDIUM |cautious user |have a way to detect when a planned meal in the future is higher than the average required intake |I won’t accidentally exceed the quota
|LOW |someone who appreciates keyboard shortcuts |have a way to recognize short forms of keywords used in the app |I can work faster
|LOW |someone who likes to motivate people |have a way to print my progress in the past month |I can motivate other people to live healthily
|LOW |someone likes different themes |have a way to change the color scheme of the application |it is easier to the eyes.
|LOW |someone likes different themes |have different colors for different tasks |I am able to distinguish between them easily.
|=======================================================================

[appendix]
== Use Cases
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC01 - Customizing User Profile

Main Success Scenario:

1. DIYeats detects that user profile has not been specified and prompts for information regarding height, weight, and lifestyle

2. Student enters the required information based on his profile

3. DIYeats indicates that user profile has been recorded.

Use case ends.

Extensions:

2.1: DIYeats detects an error in the entered data.

2.1.1: DIYeats requests for the correct data.

2.1.2: Student enters new data.

Steps 2.1.1 - 2.1.2 are repeated until the data entered are correct.

Use case resumes from step 3.

3.1: Student requests to change the user profile.

Use case resumes from step 1.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC02 - Planning Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile)

Main Success Scenario:

1. Student chooses the food he/she is planning to eat and corresponds the food to the respective meal.

2. DIYeats indicates the meal has been recorded.

3. Steps 1-2 are repeated until Student has inputted all the meals intended

Use case ends.

Extensions:

1.1: Student wants to record a meal that happened before the current day.

1.1.1: Student specifies the past date the meal occurred.

Use case resumes from step 2.

1.2: Student wants to change the nutritional value of the meal

1.2.1:  Student specifies the nutritional value of the meal.

Use case resumes from step 2.

1.3: DIYeats detects that the nutritional value exceeds the average required intake.(which is set up in UC07- Set Goal Intake)

1.3.1: DIYeats warn the Student of the anomaly and ask for confirmation/modify request.

1.3.2: Student modifies the input data or confirm the input.

Use case resumes from step 2.

1.4: DIYeats detects the wrong input from Student.

1.4.1: DIYeats prompts Student to re-enter the command.

1.4.2: Student enters the command.

Steps 1.4.1 - 1.4.2 are repeated until the command entered are correct.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC03 - List Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. NUS Student requests to display meal and the nutritional intake for today.

2. DIYeats display the recorded meals taken / will be taken today and its nutritional value.

Use Case Ends.

Extensions:

1.1: NUS Student wants to specify a date other than today

1.1.1: DIYeats display the recorded meals and intake on that date

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC04 - Remind Meals

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. User requests to be reminded on how much nutrition the student intake to reach the target nutrient intake for the month.

2. DIYeats display the information.

Use Case Ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC05 - Find meal(s)

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals are entered. (Refer to UC02 - Planning Meals).

Main Success Scenario:

1. Student requests to find a specific food student had in the past

2. DIYeats displays the queried food and its description.

Use case ends.

Extensions:

1.1: DIYeats does not recognize the food requested

1.1.1: DIYeats displays the error message.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC06 - Delete meal

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Meals can be found. (Refer to UC05 - Find meal(s)).

Main Success Scenario:

. Student requests to delete a specific food student had in the past.
. DIYeats displays the queried food and its description and the confirmation message.

Use case ends.

Extensions:

1.1: DIYeats does not recognize the food requested.

1.1.1: DIYeats displays the error message.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC07 - Set Goal Intake

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile).

Main Success Scenario:

1. Student requests for nutritional goals to be met at the end of a time frame (end of month)

2. DIYeats displays the nutritional goals that have been inputted and a confirmation goals.

3. Use case ends.

Extensions:

1.1: DIYeats detects an error in the entered data.

1.1.1: DIYeats requests for the correct data.

1.1.2: Student enters new data.

Steps 1.1.1 - 1.1.2 are repeated until the data entered are correct.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC08 - Meal Recommendation

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student unsure of what food to eat for the next meal and asks DIYeats to recommend a food that fits within the goal intake set.

2. DIYeats displays a small list of nutritional food that fit within the goal intake plan set by the student.

3. Student can choose to select food from the list generated in step 2 or proceed to key in any other food as per normal.

Use case ends.

Extensions:

1.1: DIYeats has a customizable recommendation system.

1.1.1: Student filters recommended list by meals by meal type          (only recommend food which was eaten for lunch and not dinner).

Step 1.1.1 is repeated until the student is satisfied with the constraints for food recommendation.

Use case resumes from step 2.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC09 - Generate Statistics

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student requests for the statistics of the amount of nutrients that have been eaten in a specific time frame.

2. DIYeats displays the statistics, accompanied by the goal intake that is set by the student.

Use case ends.
|=======================================================================
|=======================================================================
System: DIYeats

Actor: NUS Student

Use Case: UC10 - Generate Graphs

Preconditions: User profile is specified. (Refer to UC01 - Customizing User Profile). Some meals already eaten. ( Refer to UC02 - Planning Meals). Goal intake set. (Refer to UC07 - Set Goal Intake).

Main Success Scenario:

1. Student requests for the graph of the amount of nutrients that have been eaten in a specific time frame.

2. DIYeats displays the graph, accompanied by the goal intake that is set by the student.

Use case ends.
|=======================================================================


[appendix]
== Non-functional Requirements

* The data (user profile, meal plans, and schedule) should be persistent even if the user terminates the applications.
* The user interface should be intuitive enough to be used by a new user who has never been introduced to the program.
* The system must respond fast enough and feels snappy.
* The program must be able to be used in different platforms/operating systems (Linux, Windows, and Macintosh).
* The source code must be documented properly and adhere to the coding standards to be easily read by new developers that intend to contribute to the projects.
* The application must not violate intellectual property rights or export of restricted technologies. The third party libraries used must be approved and open source in nature.

[appendix]
== Glossary

* *Current date*: Date obtained from the system date in user’s local machine.
* *Meal*: Only includes breakfast, lunch, and dinner.
* *Session*: A period of time where the user interacts with the application. The session begins when the user launches the application, and ends when the user terminates the application.