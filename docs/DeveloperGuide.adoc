= OwlMoney - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
:experimental:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2113T-W17-3/main/tree/master

By: `Team W17-3`      Since: `Aug 2019`      Licence: `MIT`

== Setting up

=== Prerequisites
. *JDK `11`*
+
[NOTE]
Only JDK 11 is officially supported
. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle plugins installed. +
Do not disable it. If you have disabled Gradle, go to `File` > `Settings` > `Plugins` to re-enable it.

=== Setting up the project in your computer
. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen,
click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`).
It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run `owlmoney.Main` and try a few commands
. <<Testing,Run the tests>> to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, the documentation will still have the OwlMoney branding.

If you plan to develop this fork as a separate product, you should do the following:

. Configure the <<Docs-SiteWideDocSettings, site-wide documentation settings>> in link:{repoURL}/build.gradle[`build.gradle`], such as the `site-name`, to suit your own project.

. Replace the URL in the attribute `repoURL` in link:{repoURL}/docs/DeveloperGuide.adoc[`DeveloperGuide.adoc`] and link:{repoURL}/docs/UserGuide.adoc[`UserGuide.adoc`] with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading <<Design-Architecture>>.


== Design

[[Design-Architecture]]
=== Architecture
.Architecture Diagram
image::Architecture.png[width="600"]

The *_Architecture Diagram_* given above explains the high-level design of the App.
Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/owlmoney/Main.java[`Main`]. It is
responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

=== UI Component
.Ui Component Diagram
image::UiComponent.png[width="800"]

The `Ui` is responsible for printing output in a *user-friendly* manner and prints out changes made to `Model` by
`Logic`.

=== Logic Component
.High Level Logic Diagram
image::HighLevelLogic.png[width="800"]

* The `logic` package consists of the `parser`, `command` and `regex` packages.
* The `parser` package contains classes that are responsible for parsing user commands.
* The parser classes will make use of the `RegexUtil` stored in the `regex` package to verify the correctness of user
input and will return a `Command` object back to `Main` upon determining the validity of the input which is
explained in *Figure 4*.

==== Parser

.General Parser Class Diagram
image::HighLevelLogicParser.png[width="800"]

* The `Logic.parser` package consists of `Parser`, `ParseCommand`, `ParseType`, `ParseRawData` and the *abstract*
`Parser` classes that more specific parsers will inherit from.
* The `Parser` class provides *general methods* that more specific parser classes will *require*.
* The `ParseCommand` class parses the action from the user input (e.g. `/add`, `/delete`, `/edit`), before passing the user
input to the `ParseType` class for further parsing.
* The `ParseType` class will continue to parse the type of user input (e.g. `/card`, `/bank`), before passing the user input
to a more specific `Parser` class (e.g. `ParseAddCard` under the abstract class `ParseCard` which is not shown here) for further sophisticated parsing.
* The specific parser classes will then call `ParseRawData` to extract required parameters based on the Command and Type
that was determined earlier in `ParseCommand` and `ParseType` previously.
* The specific parser class will also check the correctness of the extracted parameters by using `RegexUtil` stored
in the `regex` package which is also part of the `logic` package as shown in *Figure 3*. After which, the parser class
will proceed to create an instance of the appropriate command class and return it back to `Main`.

==== Command

.Bank Command Class Diagram
image::LogicCommandBankPackage.png[width="970"]

The `logic.command.bank` package consist of `Savings` and `Investment` classes which inherits from the `Command` class.

Both the `Savings` and `Investments` classes have the following common features:

* Add
* Edit
* Delete
* List

`Main` will call the specific `Savings` or `Investment` command class that will construct the *required
parameters* before calling the `Profile` class in `Model` to *execute*.

.Bond Command Class Diagram
image::LogicCommandBondPackage.png[width="800"]

The `logic.command.bond` package consist of `Bond` classes with the following features:

* Add
* Edit
* Delete
* List

`Main` will call the specific `Bond` command class that will construct the *required parameters* before calling the
`Profile` class in `Model` to *execute*.


.Card Command Class Diagram
image::LogicCommandCardPackage.png[width="800"]

The `logic.command.card` package consist of `Card` classes with the following features:

* Add
* Edit
* Delete
* List

`Main` will call the specific `Card` command class that will construct the *required parameters* before calling the
`Profile` class in `Model` to *execute*.

.Goals Command Class Diagram
image::LogicCommandGoalsPackage.png[width="800"]

The `logic.command.goals` package consist of `Goals` classes with the following features:

* Add
* Edit
* Delete
* List

`Main` will call the specific `Goal` command class that will construct the *required parameters* before calling the
`Profile` class in `Model` to *execute*.

.Find Command Class Diagram
image::LogicCommandFindPackage.png[width="800"]

The `logic.command.find` package consist of `Find` classes with the ability to find any:

* Bank account
* Cards
* Bonds
* Card expenditure
* Bank expenditure

`Main` will call the specific `Find` command class that will construct the *required parameters* before calling the
`Profile` class in `Model` to *execute*.


.Transfer Command Class Diagram
image::LogicCommandTransferPackage.png[width="800"]

The Transfer Package under `logic.command.transfer` consist of the `TransferCommand` class which inherits from `Command`.

`Main` will call the `TransferCommand` class that will construct the *required parameters* before calling the `Profile`
class in `Model` to *execute*.


=== Model Component
.Model Component Diagram
image::ModelComponent.png[width="800"]

The `Model` contains multiple packages that is responsible for specifying the structures and constraints of the *core
functionalities* of *OwlMoney* as well as the storing of data of the application in memory.

In general, the `Model` contains the following packages:

* `bank` -> responsible for the savings and investment accounts.
* `bond` -> responsible for the investment bonds.
* `card` -> responsible for the credit cards.
* `goals` -> responsible for financial goals.
* `profile` -> responsible for the user profile.
* `transaction` -> responsible for expenditures and deposits which are classified under the umbrella term Transaction.

To execute any command, `Main` will invoke `profile.Profile` to execute commands.
`Profile` has access to each individual ArrayList such as `CardList`, `BankList`, `GoalList` that stores objects of
cards, bank accounts and financial goals respectively. Both `Card` and `Bank` objects each contains a `TransactionList`
which holds records of transactions.
If the `Card` or the `Bank` objects are *deleted*, its corresponding `TransactionList` that contains the records of
transactions *will be deleted* along with it given that it has a *composite relationship* with `TransactionList`.


=== Storage Component

To be added.

=== Common Classes

To be added.

== Implementation

=== Parsing Commands in General
.Sequence Diagram of Parsing Commands
image::GeneralParsingSequenceDiagram.png[width="970]

[NOTE]
The sequence diagram presented above is assumed to be a valid command which will generate in a successful result.

The above sequence diagram depicts the general sequence of parsing user input for all commands in general, before going
into the the specific Parser classes in `ParseTypeMenu`.

Depending on the `type` of command the user enters, the specific parser class invoked will be different (e.g.
`ParseAddBond`, `ParseDeleteInvestment`) which will return a `Command` object back to main to prepare for execution.

The execution of commands will be elaborated in subsequent diagrams below.

=== Adding Savings
.Sequence Diagram of Adding Savings
image::AddSavingCommand.png[width="970"]

[NOTE]
The sequence diagram presented above is assumed to be a valid command which will generate in a successful result.

The above sequence diagram depicts the interaction between the `Logic` and `Model` component for running
`AddSavingsCommand`.

The `AddSavingsCommand` requires *3* inputs:

. Savings Account's name
. Amount
. Income

When the user executes the `AddSavingsCommand`, the following steps are taken by the application:

. When `AddSavingsCommand` is executed, it creates a new savings object using the *3* inputs.
. After creating the savings object, the `AddSavingsCommand` will invoke the method `profileAddNewBank`.
. Within the invocation of `profileAddNewBank`, a method `bankListAddBank` will be invoked to add the new savings object
to an Arraylist containing all bank objects.
. Once `bankListAddBank` is invoked, it will perform the following checks:

* Check if the bank name specified is unique among all bank accounts in the bank list through the method
`bankAccountExists`.

[NOTE]
`bankListAddBank` will throw an error if the above check fails.

[start=5]

. After passing the above checks, `bankListAddBank` will add the new savings object to the Arraylist which contains all
bank objects.
. Once the savings object has been added, the details of the new savings object will be displayed to inform the user
of the *successful* addition of the savings object.

=== Editing Bonds
.Sequence Diagram of Editing Bonds
image::editBondCommand.png[width="970"]

[NOTE]
The sequence diagram presented above is assumed to be a valid command which will produce a successful result.

The sequence diagram presented above depicts the interaction between the `Logic` and `Model` component for running
`EditBondCommand`.

The `EditBondCommand` requires a minimum of *3* and up to a maximum of *4* inputs:

. Investment Account's name
. Bond’s name
. *At least 1* of the *2* inputs:
.. Rate
.. Year of maturity

When the user executes the `EditBondCommand`, the following steps are taken by the application:

. When `EditBondCommand` is executed, it will invoke `profileEditBond`.
. Within the invocation of `profileEditBond`, a method named `bankListEditBond` will be invoked.
. Once invoked, `bankListEditBond` will perform the following checks based on the bank name specified:

* Check for the existence of the investment account containing the bond.

[NOTE]
`bankListEditBond` will throw an error if the above check fails.

[start=4]
. After passing the above checks, the method `investmentEditBond` will be invoked.
. Within `investmentEditBond`, the method named `editBond` will be invoked.
. Once invoked, `editBond` will perform the following checks:

* Check for the existence of the bond within the investment account.
* Check whether the newly specified year of maturity for the bond is more than or equal to the current year of
maturity through the method `editBondYear`.

[NOTE]
`editBond` will throw an error if the above check fails.

[start=7]
. After passing all of the above checks, `editBond` will update the bond details with the new details specified using:
* `editBondRate` -> edits bond's interest or coupon rate.
* `editBondYear` -> edits year of maturity.

. Once the bond object has been edited, the updated details of that bond object will be displayed to inform the user
of the *successful* editing of the bond.

=== Deleting Credit Card
.Model Component Diagram
image::DeleteCardCommand.png[width="970"]

[NOTE]
The sequence diagram presented above is assumed to be a valid command which will produce a successful result.

The above sequence diagram depicts the interaction between the `Logic` and `Model` component for running
`DeleteCardCommand`.

The `DeleteCardCommand` requires *1* input:

* Credit Card’s name.

When the user executes the `DeleteCardCommand`, the following steps are taken by the application:

. When `DeleteCardCommand` is executed, it will invoke `profileDeleteCard`.
. Within the invocation of `profileDeleteCard`, a method named `cardListDeleteCard` will be invoked.
. Once invoked, `cardListDeleteCard` will perform the following checks:

* Check the Arraylist containing all card objects is not empty through the method cardListCheckListEmpty .
* Check for the existence of the card with the specified name.

[NOTE]
`cardListDeleteCard` will throw an error if any of the above checks fail.

[start=4]
. After passing the above checks, `cardListDeleteCard` will delete the card with the specified name from the Arraylist.
. Once the card object has been deleted, the details of the deleted card object will be displayed to inform the user
of the *successful* deletion of the card object.


=== Listing Credit Cards
.Model Component Diagram
image::listCardCommand.png[width="970"]

[NOTE]
The sequence diagram presented above is assumed to be a valid command which will produce a successful result.

The above sequence diagram depicts the interaction between the `Logic` and `Model` component for running
`ListCardCommand`.

The `ListCardCommand` does not require any additional input.

When the user executes the `ListCardCommand`, the following steps are taken by the application:

. When the `ListCardCommand` is executed, it will invoke `profileListCard`.
. Within the invocation of `profileListCard`, a method name `cardListListCard` will be invoked.
. Once invoked, `cardListListCard` will perform the following checks:

* Check the arraylist containing the card objects is not empty through the method cardListCheckListEmpty.

[NOTE]
`cardListListCard` will throw an error if the above check fail.

[start=4]
. After passing the above checks, `cardListListCard` will display the details of each card within the Arraylist.

=== Transferring Funds
.Model Component Diagram
image::TransferCommand.png[width="970"]

[NOTE]
The sequence diagram presented above is assumed to be a valid command which will produce a successful result.

The above sequence diagram depicts the interaction between the `Logic` and `Model` component for running
`TransferCommand`.

The `TransferCommand` requires *4* inputs:

* Sender Bank Account's name
* Receiver Bank Account's name
* Date of transfer
* Amount to transfer

When the user executes the `TransferCommand`, the following steps are taken by the application:

. When the `TransferCommand` is executed, it will invoke `transferFund`.
. Once invoked, `transferFund` will perform the following checks:

* Check the transferring account exists in the Arraylist of banks through the method `bankListIsAccountExistToReceive`.
* Check the transferring account has sufficient money for the transfer through the method
`bankListIsSufficientForTransfer`.
* Check the receiving account exists in the arraylist of bank through the method `bankListIsAccountExistToReceive`.

[NOTE]
`transferFund` will throw an error if any of the above checks fail.

[start=3]
. After passing the above checks, `transferFund` will add an expenditure to the transferring account.
. After adding an *expenditure* to the transferring account, a *deposit* will be added to the receiving account for the
fund transfer.
. Once the transfer has been completed, the details of the transfer will be displayed to inform the user of the
*successful* fund transfer.

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc,
although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="800"]

[[Docs-SiteWideDocSettings]]
=== Site-wide Documentation Settings

The link:{repoURL}/build.gradle[`build.gradle`] file specifies some project-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how all documentation files within this project are rendered.

[TIP]
Attributes left unset in the `build.gradle` file will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of site-wide attributes
|===
|Attribute name |Description |Default value

|`site-name`
|The name of the website.
If set, the name will be displayed near the top of the page.
|_not set_

|`site-githuburl`
|URL to the site's repository on https://github.com[GitHub].
Setting this will add a "View on GitHub" link in the navigation bar.
|_not set_

|`site-seedu`
|Define this attribute if the project is an official SE-EDU project.
This will render the SE-EDU navigation bar at the top of the page, and add some SE-EDU-specific navigation items.
|_not set_

|===

[[Docs-PerFileDocSettings]]
=== Per-file Documentation Settings

Each `.adoc` file may also specify some file-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how the file is rendered.

Asciidoctor's https://asciidoctor.org/docs/user-manual/#builtin-attributes[built-in attributes] may be specified and used as well.

[TIP]
Attributes left unset in `.adoc` files will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of per-file attributes, excluding Asciidoctor's built-in attributes
|===
|Attribute name |Description |Default value

|`site-section`
|Site section that the document belongs to.
This will cause the associated item in the navigation bar to be highlighted.
One of: `UserGuide`, `DeveloperGuide`, ``LearningOutcomes``{asterisk}, `AboutUs`, `ContactUs`

_{asterisk} Official SE-EDU projects only_
|_not set_

|`no-site-header`
|Set this attribute to remove the site navigation bar.
|_not set_

|===

=== Site Template

The files in link:{repoURL}/docs/stylesheets[`docs/stylesheets`] are the https://developer.mozilla.org/en-US/docs/Web/CSS[CSS stylesheets] of the site.
You can modify them to change some properties of the site's design.

The files in link:{repoURL}/docs/templates[`docs/templates`] controls the rendering of `.adoc` files into HTML5.
These template files are written in a mixture of https://www.ruby-lang.org[Ruby] and http://slim-lang.com[Slim].

[WARNING]
====
Modifying the template files in link:{repoURL}/docs/templates[`docs/templates`] requires some knowledge and experience with Ruby and Asciidoctor's API.
You should only modify them if you need greater control over the site's layout than what stylesheets can provide.
The SE-EDU team does not provide support for modified template files.
====

[[Testing]]
== Testing

=== Running Tests

There are *2* ways to run tests.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

=== Types of tests

We have two types of tests:

.. _System Tests_ that test the *OwlMoney* by running base level automated tests on https://www.appveyor.com/[AppVeyor].
.. _Unit tests_ that test the individual components. These are in `test.java` package.
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `owlmoney.model`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `owlmoney.model.bond.BondListTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `owlmoney.model.bond.BondListTest`

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_
on our projects.

See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects.

See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews
When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of
how the HTML version of those asciidoc files will look like when the pull request is merged.

See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/build.gradle[`build.gradle`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v1.8`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries.

Managing these _dependencies_ can be automated using
Gradle.

For example, Gradle can download the dependencies automatically, which is better than these alternatives:

[loweralpha]
. Include those libraries in the repo (this bloats the repo size)
. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Product Scope
*Target User Profile:*

* Undergraduates and fresh graduates
* Have some form of income in terms of allowance, pocket money or salary
* Has interest in managing his finances
* Prefers desktop applications over other types
* Able to type fast
* Prefers typing over other means of input
* Is reasonably comfortable using CLI applications

*Value Proposition:*

* Helps the target user manage their finances as they start to take charge of more money
* Helps the target user budget their expenses based on their goals
* Automatically reminds you of upcoming bills that are due to pay
* Automatically deducts or credit to account based on recurring income and expenses monthly
* See everything from account balances and expenses to give target users a full picture of their financial health.
* Works offline

[appendix]
== User Stories
Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`
[cols="5%,10%,10%,35%,35%"]
|===
|*S/N*|*Priority Level*|*As a ...*|*I can ...*|*So that I can ...*
|1|* * *|new user|create my own profile|start keeping track of my finances
|2|* * *|user|add saving accounts|categorise my finances
|3|* * *|user|add income|calculate my recommended budget
|4|* * *|existing user|edit my profile details|keep my details up to date
|5|* * *|existing user|edit my saving account|correct any errors
|6|* * *|existing user|edit my income |change it when there are changes to my income.
|7|* * *|spendthrift|add expenditures|keep track of my spending
|8|* * *|careless user|edit my expenditure|correct my errors.
|9|* * *|careless user|delete my expenditure|remove wrongly added expenses
|10|* * *|organised user|list my expenditure|have a view of my spending
|11|* * *|existing user|search for specific expenditures by category and description|search and view specific expenditure records.
|12|* *|existing user|set short and long term financial goals|I can achieve financial stability.
|13|* *|indecisive user|edit my existing financial goals|adapt to any changes
|14|* *|existing user|undo my last command|revert back to the previous state in the event of a mistake
|15|* *|existing user|compare overall expenditure of different month|review my spending
|16|* *|credit card user|add new credit cards to my account|credit my spending till the end of the month
|17|* *|credit card user|charge my expenditures to my credit card|track my credit card rebates
|18|* *|credit card user|edit my credit card details|update the details when there are changes to my card
|19|* *|spendthrift|be warned when I am close to exceeding my budget or have exceeded my budget|reduce my spending
|20|* *|existing user|recurring expenditures|relax and not need to enter it repeatedly for each month.
|21|* *|user with income|set recurring income|relax and not need to enter it repeatedly for each month.
|22|* *|existing user|view recurring expenditure|review it to check for error
|23|* *|user with income|view recurring income|review it to check for error
|24|* *|existing user|edit recurring expenditure|amend the recurring expenses when it increases or decreases
|25|* *|user with income|edit recurring income|I can remove or change it accordingly
|26|* *|existing user|be reminded when my payment is due|pay on time without penalties
|27|* *|organised user|export to view my expenditures statement|review my monthly, quarterly and yearly expenses with ease
|28|* *|achievement oriented user|gain achievements when I achieve system pre-defined goals|be motivated to pursue my financial goal
|29|* *|achievement oriented user|view different types of achievements|view my achievement that has been attained or yet to be attained
|30|* *|achievement oriented user|view the description of an achievement|understand how to achieve it
|31|* *|existing user|add investment account (bond) |track my investment bond earnings.
|32|* *|existing user|edit my investment account (bond)|amend any errors in my investment bond account
|33|* *|existing user|delete my investment account (bond)|sell it before the maturity date.
|34|* *|existing user|have my investment account’s (bond) interest being accumulated automatically every half yearly|do not have to go through the hassle of entering it manually
|35|* *|existing user|have my money transfer from one bank account to another bank account|I can organize them as investment or saving account for ease in tracking different expenditure
|36|* *|organised user|list my card details|view the specific details like cashback rate and credit limit of my card.
|37|* *|organised user|list my card expenditures|view how much I have spent and reduce my spending accordingly.
|===


[appendix]
== Use Cases
(For all use cases below, the System is OwlMoney, unless specified otherwise)

*Actor: First time user* +
[[UC-1]] *Use case: UC1 - Create new profile* +
*Main success scenario:*

. User choose to setup account.
. System requests personal details.
. User enters personal details.
. System requests for bank account details.
. User enters bank account details <<UC-2,(UC-2)>>.
. System requests for income details.
. User enters income details <<UC-3,(UC-3)>>.
. System will setup a profile tied to new bank account with the details specified.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input in personal details.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.
* 5a. System detects invalid user input in bank account details.
** 5a1. System requests for the correct user input.
** 5a2. User re-enters input.
** Steps 5a1-5a2 are repeated until the input entered are correct.
** Use case resumes from step 6.
* 7a. System detects invalid user input in income details.
** 7a1. System requests for the correct user input.
** 7a2. User re-enters input.
** Steps 7a1-7a2 are repeated until the input entered are correct.
** Use case resumes from step 8.





*Actor: User* +
[[UC-2]] *Use case: UC2 - Add bank account* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User chooses to add a bank account.
. System requests for bank account details.
. User enters details for the new bank account.
. System creates a new bank account with the details specified.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: User* +
[[UC-3]] *Use case: UC3 - Add income* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User chooses to add income.
. System requests for income details.
. User enters income details.
. System creates a new income with the details specified.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Existing User* +
[[UC-4]] *Use case: UC4 - Edit profile details* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User chooses to edit his/her profile.
. System requests for new profile details.
. User enters new profile details.
. System update the profile details
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Existing User* +
[[UC-5]] *Use case: UC5 - Edit bank account details* +
*Preconditions:*

*  *User has a profile created* +
*  *User has an existing bank account* +

*Main success scenario:*

. User chooses to edit his/her bank account details.
. System requests for new bank account details.
. User enters new bank account details.
. System update the bank account details.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Existing user* +
[[UC-6]] *Use case: UC6 - Edit income* +
*Preconditions:*

* * User has a profile created
* * User has an existing income account

*Main success scenario:*

. User chooses to edit his/her income.
. System requests new income details.
. User enters new income details.
. System updates the income details.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Spendthrift* +
[[UC-7]] *Use case: UC7 - Add expenditures record* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User chooses to add new expenditure record.
. System requests expenditure details.
. User enters expenditure details.
. System adds new expenditure record.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Careless user* +
[[UC-8]] *Use case: UC8 - Edit expenditures record* +
*Preconditions:*

* *User has a profile created*
* *User has existing expenditure records*

*Main success scenario:*

. User chooses to edit expenditure record.
. System requests new expenditure details.
. User enters new expenditure details.
. System updates the expenditure record.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Careless user* +
[[UC-9]] *Use case: UC9 -  Delete expenditure record* +
*Preconditions:*

* *User has a profile created*
* *User has existing expenditure records*

*Main success scenario:*

. User chooses to delete expenditure record.
. System requests expenditure to be deleted.
. User specifies the expenditure to be deleted.
. System deletes the specified record from the database.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Organized user* +
[[UC-10]]  *Use case: UC10 -  List expenditure record* +
*Preconditions:*

* *User has a profile created*
* *User has existing expenditure records*

*Main success scenario:*

. User chooses to list the expenditure record.
. System requests the type of expenditure to be listed.
. User specifies the type of expenditure to be listed.
. System displays the expenditure records specified.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.


*Actor: Existing user* +
[[UC-11]] *Use case: UC11 -  Search for specific expenditure record* +
*Preconditions:*

* *User has a profile created*
* *User has existing expenditure records*

*Main success scenario:*

. User chooses to search for expenditure record.
. System requests the keyword to be search.
. User specifies the keyword to be search.
. System displays information found from the search.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Existing user* +
[[UC-12]] *Use case: UC12 - Set short or long term financial goal* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User chooses to set financial goals.
. System requests the type of financial goal to be set.
. User specifies the type of financial goal to be set.
. System requests information for the financial goal.
. User enters the information required for setting the financial goal.
. System creates the financial goal.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.
* 5a. System detects invalid user input.
** 5a1. System requests for the correct user input.
** 5a2. User re-enters input.
** Steps 5a1-5a2 are repeated until the input entered are correct.
** Use case resumes from step 6.





*Actor: Indecisive user* +
[[UC-13]] *Use case: UC13 -  Edit existing financial goal* +
*Preconditions:*

* *User has a profile created*
* *User has a financial goal set up*

*Main success scenario:*

. User chooses to edit existing financial goal.
. System requests the financial goal to be edited.
. User specifies the financial goal to be edited.
. System requests the information to be edited.
. User enters the information to be updated.
. System updates existing financial goal.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.
* 5a. System detects invalid user input.
** 5a1. System requests for the correct user input.
** 5a2. User re-enters input.
** Steps 5a1-5a2 are repeated until the input entered are correct.
** Use case resumes from step 6.





*Actor: Existing user* +
[[UC-14]] *Use case: UC14 -  Undo last command* +
*Preconditions:*

* *User has a profile created*
* *User entered at least one command in the system*

*Main success scenario:*

. User enters the undo command.
. System returns to the state before the previous command is entered.
+
Use case ends.

*Extensions*

* None





*Actor: Existing user* +
[[UC-15]] *Use case: UC15 - Compare overall expenditure of different month* +
*Preconditions:*

* *User has a profile created*
* *User has at least two previous month expenditure to compare with*

*Main success scenario:*

. User chooses to compare overall expenditure of different months.
. System requests the months to be compared.
. User specifies the months to be compared.
. System displays the compared result.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Credit card user* +
[[UC-16]] *Use case: UC16 - Add credit card to account* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User chooses to add a credit card to his/her account.
. System requests the details for creating credit card.
. User enters the details for creating credit card.
. System creates the credit card.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Credit card user* +
[[UC-17]] *Use case: UC17 - Charge expenditure to credit card* +
*Preconditions:*

* *User has a profile created*
* *User has credit card added to profile*

*Main success scenario:*

. User chooses to charge expenditure to credit card.
. System requests the expenditure information.
. User enters the expenditure information.
. System creates the credit card expenditure record.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Credit card user* +
[[UC-18]] *Use case: UC18 - Edit credit card details* +
*Preconditions:*

* *User has a profile created*
* *User has credit card added to profile*

*Main success scenario:*

. User chooses to edit credit card details.
. System requests for new credit card details.
. User enters new credit card details.
. System updates the credit card details.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Spendthrift user* +
[[UC-19]] *Use case: UC19 - System warns user when exceeding or have exceeded budget* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User adds expenditure <<UC-7,(UC-7)>>.
. System warns user if total expenditure is exceeding or have exceeded budget.
+
Use case ends.

*Extensions*

* None





*Actor: Existing user* +
[[UC-20]] *Use case: UC20 - Set recurring expenditure* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User chooses to set recurring expenditure.
. System requests for details of recurring expenditure.
. User enters details of recurring expenditure.
. System creates recurring expenditure.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: User with income* +
[[UC-21]] *Use case: UC21 - Set recurring income* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User chooses to set recurring income.
. System requests for details of recurring income.
. User enters details of recurring income.
. System creates recurring income.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Existing user* +
[[UC-22]] *Use case: UC22 - View recurring expenditure* +
*Preconditions:*

* *User has a profile created*
* *User has at least a recurring expenditure.*

*Main success scenario:*

. User chooses to view recurring expenditure.
. System displays all recurring payments in chronological order.
+
Use case ends.

*Extensions*

* None





*Actor: User with income* +
[[UC-23]] *Use case: UC23 - View recurring income* +
*Preconditions:*

* *User has a profile created*
* *User has at least a recurring income.*

*Main success scenario:*

. User chooses to view recurring income.
. System displays all recurring income in chronological order.
+
Use case ends.

*Extensions*

* None





*Actor: Existing user* +
[[UC-24]] *Use case: UC24 - Edit recurring expenditure* +
*Preconditions:*

* *User has a profile created*
* *User has at least a recurring expenditure.*

*Main success scenario:*

. User chooses to edit recurring expenditure.
. System requests from user the recurring expenditure to be edited.
. User specifies the recurring expenditure.
. System requests for the new recurring expenditure details.
. User enters the new recurring expenditure details.
. System updates the recurring expenditure.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
* Use case resumes from step 4.
* 5a. System detects invalid user input.
** 5a1. System requests for the correct user input.
** 5a2. User re-enters input.
** Steps 5a1-5a2 are repeated until the input entered are correct.
** Use case resumes from step 6.



*Actor: User with income* +
[[UC-25]] *Use case: UC25 - Edit recurring income*  +
*Preconditions:*

* *User has a profile created*
* *User has at least a recurring income.*

*Main success scenario:*

. User chooses to edit recurring income.
. System requests from user the recurring income to be edited.
. User specifies the recurring income.
. System requests for the new recurring income details.
. User enters the new recurring income details.
. System updates the recurring income.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.
* 5a. System detects invalid user input.
** 5a1. System requests for the correct user input.
** 5a2. User re-enters input.
** Steps 5a1-5a2 are repeated until the input entered are correct.
** Use case resumes from step 6.





*Actor: Existing user* +
[[UC-26]] *Use case: UC26 - Reminded of due payment* +
*Preconditions:*

* *User has a profile created*
* *User has at least a recurring expenditure or credit card expenditure*

*Main success scenario:*

. User chooses to check for due payment.
. System display due payment.
+
Use case ends.

*Extensions*

* None





*Actor: Organized user* +
[[UC-27]] *Use case: UC27 - Export expenditures statement as HTML* +
*Preconditions:*

* *User has a profile created*
*Main success scenario:*

. User chooses to export expenditure statement.
. System requests for which month expenditure statement to be exported.
. User specifies the months.
. System exports the specified expenditure statement as HTML.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.


*Actor: Achievement oriented user* +
[[UC-28]] *Use case: UC28 - Gain achievement* +
*Preconditions:*

* *User has a profile created*

*Main success scenario:*

. User meets a predefined achievement criteria.
. System informs user that an achievement has been achieved.
+
Use case ends.

*Extensions*

* None





*Actor: Achievement oriented user* +
[[UC-29]] *Use case: UC29 - View different types of achievements* +
*Preconditions:*

* *User has a profile created.*

*Main success scenario:*

. User chooses to view achievements.
. System requests for types of achievement to view.
. User specifies the type of achievement.
. System displays all achievements of the specified type.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Achievement oriented user* +
[[UC-30]] *Use case: UC30 - View description of an achievement* +
*Preconditions:*

* *User has a profile created.*
*Main success scenario:*

. User chooses to view achievement description.
. System requests for which specific achievement to view.
. User specifies the achievement.
. System displays description of the achievement.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Existing user* +
[[UC-31]] *Use case: UC31 - Add investment account (bond)* +
*Main success scenario:*

. User choose to add investment account.
. System requests for investment account details.
. User enters investment account details.
. System creates an investment account.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input in personal details.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.



*Actor: Existing user* +
[[UC-32]] *Use case: UC32 - Edit investment account (bond)* +
*Main success scenario:*

. User choose to edit investment account.
. System requests for new investment account details.
. User enters investment account details.
. System updates the investment account.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input in personal details.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.




*Actor: Existing user* +
[[UC-33]] *Use case: UC33 - Delete investment account (bond)* +
*Main success scenario:*

. User choose to delete investment account.
. System requests for investment account to be deleted.
. User selects the investment account to be deleted.
. System deletes the investment account.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input in personal details.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Existing user* +
[[UC-34]] *Use case: UC34 - Automatically calculate half yearly interest for investment account (bond)* +
*Main success scenario:*

. User starts up the program.
. System runs the check and calculate the interest accordingly.
+
Use case ends.

*Extensions*

* None





*Actor: Existing user* +
[[UC-35]] *Use case: UC35 - Transfer money between different bank accounts* +
*Main success scenario:*

. User choose to transfer money to another bank account.
. System requests for destination account and amount to transfer.
. User enters the details of destination account and amount to transfer.
. System transfers the amount to the specified account.
+
Use case ends.

*Extensions*
[none]
* 3a. System detects invalid user input in personal details.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





*Actor: Organized User* +
[[UC-36]] *Use case: UC36 - Gain achievement* +
*Preconditions:*

* *User has a profile created*
* *User has added a credit card to the profile*

*Main success scenario:*

. User choose to list credit card details.
. System displays all credit card details.
+
Use case ends.

*Extensions*

* None





*Actor: Organized User* +
[[UC-37]] *Use case: UC37 - Gain achievement* +
*Preconditions:*

* *User has a profile created*
* *User has added a credit card to the profile*
* *User has expenditure added to credit card*

*Main success scenario:*

. User chooses to list the card expenditure record.
. System requests name of the card for the expenditure to be listed.
. User specifies the name of the card for the expenditure to be listed.
. System displays the expenditure records specified.
+
Use case ends.

*Extensions*

* 3a. System detects invalid user input.
** 3a1. System requests for the correct user input.
** 3a2. User re-enters input.
** Steps 3a1-3a2 are repeated until the input entered are correct.
** Use case resumes from step 4.





[appendix]
== Non Functional Requirements
. The application should work on any computer running a <<mainstream-os, mainstream OS>> OS that has Java 11 installed.
. The application should work on both 32-bit and 64-bit environments.
. The application should work without requiring any internet access.
. The application should work without requiring an installer.
. The application should be able to store at least 3500 transactions per year.
. A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most tasks faster using CLI than GUI.
. The application should store relevant user data locally on the filesystem and should be persistent, ensuring that the data can be restored on the next startup of the application.
. The application should have good user documentation, which details all aspects of the application to assist new users on how to use this application.
. The application should have good developer documentation to allow developers to understand the design of the application easily so that they can further develop it.
. The application should be easily testable.

[appendix]
== Glossary
[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[appendix]
== Instructions for Manual Testing
